package bitmap;

/**
 * 位图
 * 通常基于数组实现。
 * 可以将数组中的每个元素都看做一系列二进制数，所有元素一起组成更大的二进制集合
 * 这样就可以节省很多空间
 * <p>
 * 位图通常用来判断某个数据存不存在，常用在判断数据是否存在，还可以用于无重复整数的排序
 * <p>
 * 在 Java 中使用 byte[] 字节数组来存储 bit ， 1 byte = 8 bit
 * <p>
 * 对于 bit 中的第 i 位，该 bit 为 1 则表示 true，即数据存在； 为 0 表示 false，即数据不存在
 */
public class Bitmap {
    // 存储具体的数据
    private byte[] bytes;
    // 位图的长度
    private int length;

    public Bitmap(int length) {
        this.length = length;
        // this.bytes = new byte[length % 8 == 0 ? length / 8 : length / 8 + 1];
        this.bytes = new byte[(length & 7) == 0 ? length >> 3 : length >> 3 + 1];
    }

    /**
     * 查询方法的实现，获取指定位的值
     * <p>
     * 因为 1 byte = 8 bit
     * <p>
     * 所以 M × N 的 byte 数组，可以存储 M × N × 8 个数据
     * <p>
     * 假如要存储 1 ~ 15 的数据，只需要使用 M = 1； N = 2 的数组即可，如下：
     * <p>
     * -------------------------------------------------------------------
     * |           byte[1]              |            byte[0]             |
     * -------------------------------------------------------------------
     * |                                |                                |
     * | 15  14  13  12  11  10  9   8  |  7   6   5   4   3   2   1   0 |
     * | 1   0   0   0   0   1   0   0  |  0   1   0   0   1   0   1   0 |
     * |                                |                                |
     * -------------------------------------------------------------------
     * <p>
     * 位图的查询操作为在拿到目标 bit 所在的 byte 后，将该 byte 向右位移（并将高位置为 0），使目标 bit 在第 1 位，这样结果值就是目标 bit 值
     * <p>
     * 1、通过 byte[index >> 3]， 等价于 byte[index / 8] 取到目标 bit 所在的 byte
     *      因为这是一个 M × N 的 byte 数组，可以存储 M × N × 8 个数据，本例中存储 16 个数据，使用的是 M = 1， N = 2 的 byte 数组
     *      所以 byte[index >> 3] 取到的就是数据在的 byte[2] 中的索引
     * 2、令 i = index & 7， 等价于 index % 8， 得到目标 bit 在该 byte 的位置
     *      因为一个 byte 占 8 位，所以 index & 7 取到目标 bit 在 byte 中占用的位置，比如 10 ，就是在 byte[1] 中的第 2 个位置
     * 3、为了将目标 bit 前面的高位置为 0，这样位移之后的值才等于目标 bit 本身，
     *      需要构造目标 bit 为止的低位掩码，即 01111111 >>> (7 - i)
     *      再与原来的 byte 做 & 运算
     * 4、将结果右移 i 位，使目标 bit 处于第 1 位，结果即为所求
     *
     * @param index
     * @return
     */

    public boolean get(int index) {
        int i = index & 7;// bit 在 byte 中的位置
        // 构建到 index 结束的低位掩码并做 & 运算（将高位置为 0），然后将结果一直右移直到目标（index 位）移到第 1 位，然后根据值返回结果
//        if ((bytes[index >> 3] & (01111111 >>> (7 - i))) >> i == 0)
//            return false;
//        return true;

        return ((bytes[index >> 3] >> i) & 00000001) == 1;

        /* 以 index = 10 为例，模拟执行过程 */
        /*
         *  1:      index = 10
         *  2:      get(10)
         *  3:      i = 10 & 7      实际上等同于 10 % 8 = 2，
         *                  具体过程：  10 & 7
         *         转换为二进制等同于    0b00001010 & 0b00000111
         *                      等于    0b00000010
         *              转换为十进制 =  2
         *  4:      构建 index 结束的低位掩码
         *              01111111 >>> (7 - i)
         *          等于
         *              01111111 >>> 5
         *          等于0b10000100
         *              00000011
         *  5:      做 & 运算，将高位置为 0
         *              00000011 & byte[index >> 3]
         *          等于
         *              00000011 & byte[00001010 >>> 3]
         *          等于
         *              00000011 & byte[1]
         *          等于
         *              00000011 & 10000100
         *          等于
         *              00000000
         * */
    }

    /**
     * 修改实现。设置指定的值
     * <p>
     * 位图修改操作根据设定值 true 和 false 的不同，分两种情况：
     * 1、如果 value 为 true， 则表示数据存在，将目标位与 1 做 或 运算，需要构建目标位为 1、其他位为 0 的操作数
     * 2、如果 value 为 false， 则表示数据不存在，将目标位与 0 作 与 运算，需要构建目标位为 0、其他位为 1 的操作数
     * <p>
     * 构建目标位为 1 且其他位为 0 的操作数的做法为：
     * 1 << (index & 7)
     *
     * @param index
     * @param value
     */

    /*
        以构建 get 的注释中所示数据为例，模拟执行过程
     */
    public void set(int index, boolean value) {
        if (value) {
            // 通过给定位 index，定位到对应 byte，并根据 value 值进行不同的操作
            // 1、如果 value 为 true， 则目标位应该做 或 运算，构建     目标位为 1， 其他位为 0     的操作数
            //      为了只合理操作目标位，不影响其他位
            // 2、如果 value 为 false， 则目标位应该做 与 运算，构建      目标位为 0， 其他位为 1      的操作数
            bytes[index >> 3] |= 1 << (index & 7);
            // bytes[index / 8] = bytes[index / 8] | (0b0001 << (index % 8))
        } else {
            bytes[index >> 3] &= ~(1 << (index & 7));
        }

        /*
            set(0, false);          bytes[0 >> 3] &= ~(1 << (0 & 7))    相当于     bytes[0] &= ~(1 << (0 & 7))
                                                                                        = 0000 0000 & 1111 1110
                                                                                        = 0000 0000


            set(1, true);           bytes[1 >> 3] |= 1 << (1 & 7)       相当于     bytes[0] |= 1 << (1 & 7)
                                                                                        = 0000 0000 | 1 << (1 & 7)
                                                                                        = 0000 0000 | 0000 0010
                                                                                        = 0000 0010

            set(2, false);          bytes[2 >> 3] &= ~(1 << (2 & 7))    相当于     bytes[0] &= ~(1 << (2 & 7))
                                                                                        = 0000 0010 & ~(1 << (2 & 7))
                                                                                        = 0000 0010 & 1111 1011
                                                                                        = 0000 0010

            set(3, true);           bytes[3 >> 3] |= 1 << (3 & 7)       相当于     bytes[0] |= (1 << (3 & 7))
                                                                                        = 0000 0010 | 1 << (3 & 7)
                                                                                        = 0000 0010 | 0000 1000
                                                                                        = 0000 1010

            set(4, false);          bytes[4 >> 3] &= ~(1 << (4 & 7))    相当于     bytes[0] &= ~(1 << (4 & 7))
                                                                                        = 0000 1010 & 1110 1111
                                                                                        = 0000 1010

            set(5, false);          bytes[5 >> 3] &= ~(1 << (5 & 7))    相当于     bytes[0] &= ~(1 << (5 & 7))
                                                                                        = 0000 1010 & 1101 1111
                                                                                        = 0000 1010

            set(6, true);           bytes[6 >> 3] |= 1 << (6 & 7)       相当于     bytes[0] |= 1 << (6 & 7)
                                                                                        = 0000 1010 | 0100 0000
                                                                                        = 0100 1010

            set(7, false);          bytes[7 >> 3] &= ~(1 << (7 & 7))    相当于     bytes[0] &= ~(1 << (7 & 7))
                                                                                        = 0100 1010 & 0111 1111
                                                                                        = 0100 1010

            -------------------------------- 注意：        这里 bytes[0] 存储满了 ---------------------------------------
            -------------------------------- 注意： 这里存储空间进入到 bytes[1] 了 ---------------------------------------

            set(8, false);          bytes[8 >> 3] &= ~(1 << (8 & 7))    相当于     bytes[1] &= ~(1 << (8 & 7))
                                                                                        = 0000 0000 & 1111 1110
                                                                                        = 0000 0000

            set(9, false);          bytes[9 >> 3] &= ~(1 << (8 & 7))    相当于     bytes[1] &= ~(1 << (9 & 7))
                                                                                        = 0000 0000 & 1111 1101
                                                                                        = 0000 0000

            set(10, true);          bytes[10 >> 3] |= 1 << (10 & 7)     相当于     bytes[1] |= 1 << (10 & 7)
                                                                                        = 0000 0000 | 0000 0100
                                                                                        = 0000 0100

            set(11, false);         bytes[11 >> 3] &= ~(1 << (11 & 7))  相当于     bytes[1] = 0000 0100
            set(12, false);         bytes[12 >> 3] &= ~(1 << (12 & 7))  相当于     bytes[1] = 0000 0100
            set(13, false);         bytes[13 >> 3] &= ~(1 << (13 & 7))  相当于     bytes[1] = 0000 0100
            set(14, false);         bytes[14 >> 3] &= ~(1 << (14 & 7))  相当于     bytes[1] = 0000 0100
            set(15, true);          bytes[15 >> 3] |= 1 << (15 & 7)     相当于     bytes[1] = 1000 0100

            所以，此时， byte 内部应该如下：

                byte 的值应该为：     1000 0100 0100 1010

                字节位置：   15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
                存储数据：   1   0   0   0   0   1   0   0   0   1   0   0   1   0   1   0
             */
    }
}
