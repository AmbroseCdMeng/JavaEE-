# 动态代理模式

> 动态代理的意义在于生成一个占位（代理对象）来代理真实对象，从而控制对象的访问
>
> 代理的作用就是，在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象

## JDK 动态代理
> JDK 动态代理是 `java.lang.reflect.*` 包提供的方式，必须借助一个接口才能产生代理对象

> JDK 动态代理中，要实现代理逻辑类必须去实现 `java.lang.reflect.InvocationHandler` 接口，里面定义了一个 `invock` 方法
>

- 定义接口
    ```java
    package com.ambrose.proxypattern;
  
    public interface HelloWorld {
        void sayHelloWorld();
    }
    ```
  
- 实现接口
    ```java
    package com.ambrose.proxypattern;
  
    import com.ambrose.proxypattern.jdkproxypattern.HelloWorld;public class HelloWorldImpl implements HelloWorld {
        @Override
        public void sayHelloWorld(){
            System.out.println("Hello World");
        }
    }
    ```
- 代理逻辑类
    ```java
    package com.ambrose.proxypattern;
    
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    
    public class JdkProxyExample implements InvocationHandler {
    
        //真实对象
        private Object target = null;
    
        /**
         * 建立代理对象和真是对象的代理关系，并返回代理对象
         * @param target 真实对象
         * @return 代理对象
         */
        public Object bind(Object target){
            // 保存真实对象
            this.target = target;
            // 建立并生成代理对象
            /* Proxy.newProxyInstance 方法需要三个参数：
                1、类加载器。
                    这里采用 target 类本身的加载器
                2、表示最终生成的动态代理对象挂载在哪些接口下。
                    这里将其挂在 target 类实现的接口下
                3、定义实现方法逻辑的代理类，必须实现 InvocationHandler 的 invoke 方法
                    这里 this 表示当前对象
             */
            return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this );
        }
    
        /**
         * 代理方法逻辑
         * @param proxy 代理对象（就是 bind 方法生成的对象）
         * @param method    当前调度的方法
         * @param args  当前调度方法参数
         * @return  代理结果返回
         * @throws Throwable    异常
         */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("进入代理逻辑方法");
            System.out.println("在调度真实对象之前的服务");
            Object obj = method.invoke(target, args);
            System.out.println("在调度真实对象之后的服务");
            return obj;
        }
    }
    ```

- 测试 JDK 动态代理
    ```java
    package com.ambrose.proxypattern;
    
    import com.ambrose.proxypattern.jdkproxypattern.HelloWorld;import com.ambrose.proxypattern.jdkproxypattern.HelloWorldImpl;import com.ambrose.proxypattern.jdkproxypattern.JdkProxyExample;import org.junit.Test;
    
    public class TestProxyPattern {
        @Test
        public void testJdkProxy(){
            JdkProxyExample jdk = new JdkProxyExample();
            // 绑定关系，因为挂在接口 HelloWorld 下，所以声明代理对象 HelloWorld proxy
            HelloWorld proxy = (HelloWorld)jdk.bind(new HelloWorldImpl());
            // 此时，HelloWorld 对象已经是一个代理对象，它会进入代理的逻辑方法 invoke 里
            proxy.sayHelloWorld();
        }
    }
    ```

## CGLIB 动态代理

> CGLIB 动态代理不需要提供结构，只要一个非抽象类就能实现动态代理。
